Es gibt beim Triple anlegen mit RDFSharp grundsätzlich zwei Arten, die Daten im Triple zu repräsentieren.

Die Klassen: RDFPlainLiteral/RDFTypedLiteral
Oder die Klasse: RDFResource

RDFResource bekommt eine URI welche das Objekt beschreibt, ist für unseren Anwendungsfall also wohl
eher nebensächlich.

RDFPlainLiteral bekommt einen String, welcher die Daten repräsentiert.
RDFTypedLiteral bekommt einen String, welcher die Daten repräsentiert, und einen Typ, welcher den Typ des angegebenen Strings
repräsentiert.

Ein Triple in RDFSharp ist ein Objekt welches aus 3 RDFResources oder RDFLiterals besteht.

Beispiel wäre: 
new RDFTriple(new RDFPlainLiteral("Tom"), new RDFPlainLiteral("ist"), new RDFPlainLiteral("Ein Wappla"));

Das Prädikat darf nicht leer sein und wird von RDFSharp geprüft. Falls leer, fliegt eine RDFModelException.
Weiß nicht was passiert wenn prädikat NULL ist.

Ein Graph (RDFGraph) ist eine Ansammlung von Triples
Graph kann auch von einem DataTable instanziert werden, per RDFGraph.FromDataTable(table);
Ein Graph implementiert einen IEnumerator.
Grph.TriplesCount gibt die Anzahl an Triples zurück.

Schaut so aus als könnte der Graph unser TripleStore sein.

### Import von Triples aus CSV-Files 

Dieses Kapitel beschäftigt sich mit dem Import von Triples aus CSV Dateien. 
Die relevante Komponente dafür ist der CSVDataReader. Dieser liest mit Hilfe des angegebenen Pfads, zur CSV-Datei, die Daten der Triple ein.
Die Methodensignatur für das einlesen der Daten schaut, wie folgt, aus:

```public IEnumerable<RawTripleData> Read(string path)```

Hier bekommen wir in Form eines Enumberable unsere Raw Triples zurück die dann in eine Ontologie integriert werden können. Doch davor werden diese an den sogenannten
Triple parser übergeben. Dieser validiert die Mindestanforderungen/ Contraints für ein Raw Triple. 